Kleefl 
======
### Linking symbolic execution results by Klee to afl-fuzz

---

## Example of usage:

### Get vagrant box

    https://owncloud.sec.t-labs.tu-berlin.de/owncloud/public.php?service=files&t=2c28a437ebb75a33ee127dd4ea827726

### Setup project structrue

    mkdir project_xyz
    cd project_xyz
    /vagrant/tools/kleefl_init


### Setup your source code dir in the project dir, like:

    cp -r /vagrant/example source

### Build the source with wllvm & afl-clang

    cd source
    /vagrant/tools/kleefl_build make 	// in case of exmaple proj, just "make"

### Run Klee symbolic execution
    
    cd ../klee 		// go to project klee dir
    ./run_klee		// run klee with default setup (feel free to change)

### Prepare Klee findings for afl-fuzz
    
    cd ..			// go to project root dir
    /vagrant/tools/kleefl_prepare_fuzzing

### Finally: Fuzz!
    
    cd fuzz
    ./run_afl.sh 	// run afl-fuzz instances, generated by kleefl_prepare_fuzzing

---

## Some more details

### ./kleefl_init {clean}
+ build file/dir structure
+ copy run_klee.sh & run_afl.sh
+ clean to remove structure

### ./kleefl_build {make, make afl, make klee, clean, clean afl, clean klee}
+ make source with wllvm
+ make source with afl-gcc / afl-clang (afl-clang faster fuzzing!?)

### ./kleefl_pick application_binary_name
+ copy application from build dir to fuzz & klee roots
(default target naming: app -> afl-fuzz / app.bc -> klee )

### ./run_klee.sh
+ run klee instance with default setup

### ./kleefl_prepare_fuzzing 
+ sort crashing, non-crashing
+ group calls with equal arguments
+ filter useless afl-calls without any fileusage

### ./fuzz/run_afl.sh 
+ run grouped instances of afl-fuzz
	- same args, non-crashing
	- same args, crashing
	(- dictonary (-x opetion))
+ fill up for multicore stuff?